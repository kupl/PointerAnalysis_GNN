  <java.io.FilterInputStream: void <init>(java.io.InputStream)>
  <java.io.FilterOutputStream: void <init>(java.io.OutputStream)>
  <java.io.PrintStream: void <init>(boolean,java.io.OutputStream)>
  <java.io.PrintStream: void <init>(java.io.OutputStream)>
  <java.io.PrintStream: void <init>(java.io.OutputStream,boolean)>
  <java.lang.ClassLoader: java.lang.Package definePackage(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.net.URL)>
  <java.lang.ClassLoader: java.lang.Package getPackage(java.lang.String)>
  <java.lang.ClassLoader: void <init>(java.lang.Void,java.lang.ClassLoader)>
  <java.lang.Object: java.lang.Object clone()>
  <java.lang.ref.Finalizer: void access$100(java.lang.ref.Finalizer)>
  <java.lang.ref.Finalizer: void <init>(java.lang.Object)>
  <java.lang.ref.Finalizer: void runFinalizer()>
  <java.lang.ref.FinalReference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
  <java.lang.ref.Reference: java.lang.Object get()>
  <java.lang.ref.Reference: void <init>(java.lang.Object)>
  <java.lang.ref.Reference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
  <java.lang.ref.SoftReference: java.lang.Object get()>
  <java.lang.ref.SoftReference: void <init>(java.lang.Object)>
  <java.lang.ref.SoftReference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
  <java.lang.ref.WeakReference: void <init>(java.lang.Object)>
  <java.lang.ref.WeakReference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
  <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>
  <java.lang.StringCoding: java.lang.Object deref(java.lang.ThreadLocal)>
  <java.lang.String: java.lang.String valueOf(java.lang.Object)>
  <java.lang.System: void setProperties(java.util.Properties)>
  <java.lang.ThreadGroup: void add(java.lang.Thread)>
  <java.lang.ThreadGroup: void add(java.lang.ThreadGroup)>
  <java.lang.ThreadLocal: java.lang.Object get()>
  <java.lang.ThreadLocal: java.lang.Object setInitialValue()>
  <java.lang.ThreadLocal$ThreadLocalMap: boolean cleanSomeSlots(int,int)>
  <java.lang.ThreadLocal$ThreadLocalMap$Entry: void <init>(java.lang.ThreadLocal,java.lang.Object)>
  <java.lang.ThreadLocal$ThreadLocalMap: int expungeStaleEntry(int)>
  <java.lang.ThreadLocal$ThreadLocalMap: java.lang.ThreadLocal$ThreadLocalMap$Entry access$000(java.lang.ThreadLocal$ThreadLocalMap,java.lang.ThreadLocal)>
  <java.lang.ThreadLocal$ThreadLocalMap: java.lang.ThreadLocal$ThreadLocalMap$Entry getEntryAfterMiss(java.lang.ThreadLocal,int,java.lang.ThreadLocal$ThreadLocalMap$Entry)>
  <java.lang.ThreadLocal$ThreadLocalMap: java.lang.ThreadLocal$ThreadLocalMap$Entry getEntry(java.lang.ThreadLocal)>
  <java.lang.ThreadLocal$ThreadLocalMap: void access$100(java.lang.ThreadLocal$ThreadLocalMap,java.lang.ThreadLocal,java.lang.Object)>
  <java.lang.ThreadLocal$ThreadLocalMap: void expungeStaleEntries()>
  <java.lang.ThreadLocal$ThreadLocalMap: void <init>(java.lang.ThreadLocal,java.lang.Object)>
  <java.lang.ThreadLocal$ThreadLocalMap: void rehash()>
  <java.lang.ThreadLocal$ThreadLocalMap: void replaceStaleEntry(java.lang.ThreadLocal,java.lang.Object,int)>
  <java.lang.ThreadLocal$ThreadLocalMap: void resize()>
  <java.lang.ThreadLocal$ThreadLocalMap: void set(java.lang.ThreadLocal,java.lang.Object)>
  <java.lang.ThreadLocal: void createMap(java.lang.Thread,java.lang.Object)>
  <java.lang.ThreadLocal: void set(java.lang.Object)>
  <java.lang.Thread: void start()>
  <java.lang.Throwable: java.lang.Throwable initCause(java.lang.Throwable)>
  <java.net.InetAddress$Cache: java.net.InetAddress$CacheEntry get(java.lang.String)>
  <java.net.URLClassLoader: java.lang.Package definePackage(java.lang.String,java.util.jar.Manifest,java.net.URL)>
  <java.net.URLClassLoader: void addURL(java.net.URL)>
  <java.nio.charset.CoderResult$Cache: java.nio.charset.CoderResult access$200(java.nio.charset.CoderResult$Cache,int)>
  <java.nio.charset.CoderResult$Cache: java.nio.charset.CoderResult get(int)>
  <java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>
  <java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>
  <java.text.BreakIterator: java.lang.Object clone()>
  <java.text.DecimalFormat: java.lang.Object clone()>
  <java.text.DecimalFormatSymbols: java.lang.Object clone()>
  <java.text.DigitList: java.lang.Object clone()>
  <java.text.Format: java.lang.Object clone()>
  <java.text.NumberFormat: java.lang.Object clone()>
  <java.text.RuleBasedBreakIterator: java.lang.Object clone()>
  <java.text.RuleBasedBreakIterator$SafeCharIterator: java.lang.Object clone()>
  <java.util.AbstractCollection: boolean addAll(java.util.Collection)>
  <java.util.AbstractCollection: boolean retainAll(java.util.Collection)>
  <java.util.AbstractCollection: java.lang.Object[] finishToArray(java.lang.Object[],java.util.Iterator)>
  <java.util.AbstractCollection: java.lang.Object[] toArray()>
  <java.util.AbstractCollection: java.lang.Object[] toArray(java.lang.Object[])>
  <java.util.AbstractCollection: java.lang.String toString()>
  <java.util.AbstractList$Itr: java.lang.Object next()>
  <java.util.AbstractList$Itr: void <init>(java.util.AbstractList)>
  <java.util.AbstractList$Itr: void <init>(java.util.AbstractList,java.util.AbstractList$1)>
  <java.util.AbstractList: java.util.Iterator iterator()>
  <java.util.AbstractList: java.util.ListIterator listIterator()>
  <java.util.AbstractMap: boolean containsKey(java.lang.Object)>
  <java.util.AbstractSequentialList: java.util.Iterator iterator()>
  <java.util.ArrayList: boolean addAll(java.util.Collection)>
  <java.util.ArrayList: boolean add(java.lang.Object)>
  <java.util.ArrayList: boolean contains(java.lang.Object)>
  <java.util.ArrayList: int indexOf(java.lang.Object)>
  <java.util.ArrayList$Itr: java.lang.Object next()>
  <java.util.ArrayList$Itr: void <init>(java.util.ArrayList)>
  <java.util.ArrayList$Itr: void <init>(java.util.ArrayList,java.util.ArrayList$1)>
  <java.util.ArrayList$Itr: void remove()>
  <java.util.ArrayList: java.lang.Object[] access$200(java.util.ArrayList)>
  <java.util.ArrayList: java.lang.Object elementData(int)>
  <java.util.ArrayList: java.lang.Object get(int)>
  <java.util.ArrayList: java.lang.Object remove(int)>
  <java.util.ArrayList: java.lang.Object set(int,java.lang.Object)>
  <java.util.ArrayList: java.lang.Object[] toArray()>
  <java.util.ArrayList: java.lang.Object[] toArray(java.lang.Object[])>
  <java.util.ArrayList: java.util.Iterator iterator()>
  <java.util.ArrayList: java.util.ListIterator listIterator()>
  <java.util.ArrayList: java.util.ListIterator listIterator(int)>
  <java.util.ArrayList$ListItr: java.lang.Object previous()>
  <java.util.ArrayList$ListItr: void <init>(java.util.ArrayList,int)>
  <java.util.ArrayList$ListItr: void set(java.lang.Object)>
  <java.util.ArrayList$SubList$1: java.lang.Object next()>
  <java.util.ArrayList: void add(int,java.lang.Object)>
  <java.util.ArrayList: void ensureCapacity(int)>
  <java.util.ArrayList: void <init>()>
  <java.util.ArrayList: void <init>(int)>
  <java.util.ArrayList: void <init>(java.util.Collection)>
  <java.util.Arrays$ArrayList: java.lang.Object get(int)>
  <java.util.Arrays$ArrayList: void <init>(java.lang.Object[])>
  <java.util.Arrays: java.lang.Object[] copyOf(java.lang.Object[],int)>
  <java.util.Arrays: java.lang.Object[] copyOf(java.lang.Object[],int,java.lang.Class)>
  <java.util.Arrays: java.util.List asList(java.lang.Object[])>
  <java.util.Arrays: void mergeSort(java.lang.Object[],java.lang.Object[],int,int,int)>
  <java.util.Arrays: void mergeSort(java.lang.Object[],java.lang.Object[],int,int,int,java.util.Comparator)>
  <java.util.Arrays: void sort(java.lang.Object[])>
  <java.util.Arrays: void sort(java.lang.Object[],java.util.Comparator)>
  <java.util.Arrays: void swap(java.lang.Object[],int,int)>
  <java.util.Calendar: java.lang.Object clone()>
  <java.util.Collections: java.util.Collection synchronizedCollection(java.util.Collection,java.lang.Object)>
  <java.util.Collections: java.util.Map synchronizedMap(java.util.Map)>
  <java.util.Collections: java.util.Set synchronizedSet(java.util.Set)>
  <java.util.Collections: java.util.Set synchronizedSet(java.util.Set,java.lang.Object)>
  <java.util.Collections$SynchronizedCollection: boolean add(java.lang.Object)>
  <java.util.Collections$SynchronizedCollection: java.lang.Object[] toArray()>
  <java.util.Collections$SynchronizedCollection: java.util.Iterator iterator()>
  <java.util.Collections$SynchronizedCollection: void <init>(java.util.Collection)>
  <java.util.Collections$SynchronizedCollection: void <init>(java.util.Collection,java.lang.Object)>
  <java.util.Collections$SynchronizedMap: boolean containsKey(java.lang.Object)>
  <java.util.Collections$SynchronizedMap: java.lang.Object get(java.lang.Object)>
  <java.util.Collections$SynchronizedMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
  <java.util.Collections$SynchronizedMap: java.util.Collection values()>
  <java.util.Collections$SynchronizedMap: void <init>(java.util.Map)>
  <java.util.Collections$SynchronizedSet: void <init>(java.util.Set)>
  <java.util.Collections$SynchronizedSet: void <init>(java.util.Set,java.lang.Object)>
  <java.util.Collections: void reverse(java.util.List)>
  <java.util.Collections: void sort(java.util.List)>
  <java.util.Collections: void sort(java.util.List,java.util.Comparator)>
  <java.util.GregorianCalendar: java.lang.Object clone()>
  <java.util.HashMap: boolean containsKey(java.lang.Object)>
  <java.util.HashMap$EntryIterator: java.lang.Object next()>
  <java.util.HashMap$EntryIterator: java.util.Map$Entry next()>
  <java.util.HashMap$EntryIterator: void <init>(java.util.HashMap)>
  <java.util.HashMap$EntryIterator: void <init>(java.util.HashMap,java.util.HashMap$1)>
  <java.util.HashMap$Entry: java.lang.Object getKey()>
  <java.util.HashMap$Entry: java.lang.Object getValue()>
  <java.util.HashMap$EntrySet: java.util.Iterator iterator()>
  <java.util.HashMap$EntrySet: void <init>(java.util.HashMap)>
  <java.util.HashMap$EntrySet: void <init>(java.util.HashMap,java.util.HashMap$1)>
  <java.util.HashMap$Entry: void <init>(int,java.lang.Object,java.lang.Object,java.util.HashMap$Entry)>
  <java.util.HashMap$HashIterator: java.util.HashMap$Entry nextEntry()>
  <java.util.HashMap$HashIterator: void <init>(java.util.HashMap)>
  <java.util.HashMap: java.lang.Object getForNullKey()>
  <java.util.HashMap: java.lang.Object get(java.lang.Object)>
  <java.util.HashMap: java.lang.Object putForNullKey(java.lang.Object)>
  <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
  <java.util.HashMap: java.lang.Object remove(java.lang.Object)>
  <java.util.HashMap: java.util.Collection values()>
  <java.util.HashMap: java.util.HashMap$Entry getEntry(java.lang.Object)>
  <java.util.HashMap: java.util.HashMap$Entry removeEntryForKey(java.lang.Object)>
  <java.util.HashMap: java.util.Iterator newEntryIterator()>
  <java.util.HashMap: java.util.Iterator newKeyIterator()>
  <java.util.HashMap: java.util.Iterator newValueIterator()>
  <java.util.HashMap: java.util.Set entrySet()>
  <java.util.HashMap: java.util.Set entrySet0()>
  <java.util.HashMap: java.util.Set keySet()>
  <java.util.HashMap$KeyIterator: java.lang.Object next()>
  <java.util.HashMap$KeyIterator: void <init>(java.util.HashMap)>
  <java.util.HashMap$KeyIterator: void <init>(java.util.HashMap,java.util.HashMap$1)>
  <java.util.HashMap$KeySet: java.util.Iterator iterator()>
  <java.util.HashMap$KeySet: void <init>(java.util.HashMap)>
  <java.util.HashMap$KeySet: void <init>(java.util.HashMap,java.util.HashMap$1)>
  <java.util.HashMap$ValueIterator: java.lang.Object next()>
  <java.util.HashMap$ValueIterator: void <init>(java.util.HashMap)>
  <java.util.HashMap$ValueIterator: void <init>(java.util.HashMap,java.util.HashMap$1)>
  <java.util.HashMap$Values: java.util.Iterator iterator()>
  <java.util.HashMap$Values: void <init>(java.util.HashMap)>
  <java.util.HashMap$Values: void <init>(java.util.HashMap,java.util.HashMap$1)>
  <java.util.HashMap: void addEntry(int,java.lang.Object,java.lang.Object,int)>
  <java.util.HashMap: void createEntry(int,java.lang.Object,java.lang.Object,int)>
  <java.util.HashMap: void <init>()>
  <java.util.HashMap: void <init>(int)>
  <java.util.HashMap: void <init>(int,float)>
  <java.util.HashMap: void <init>(java.util.Map)>
  <java.util.HashMap: void putAllForCreate(java.util.Map)>
  <java.util.HashMap: void putForCreate(java.lang.Object,java.lang.Object)>
  <java.util.HashMap: void resize(int)>
  <java.util.HashMap: void transfer(java.util.HashMap$Entry[])>
  <java.util.HashSet: boolean add(java.lang.Object)>
  <java.util.HashSet: boolean contains(java.lang.Object)>
  <java.util.HashSet: java.util.Iterator iterator()>
  <java.util.HashSet: void <init>()>
  <java.util.HashSet: void <init>(int)>
  <java.util.HashSet: void <init>(int,float,boolean)>
  <java.util.Hashtable$EntrySet: java.util.Iterator iterator()>
  <java.util.Hashtable$EntrySet: void <init>(java.util.Hashtable)>
  <java.util.Hashtable$EntrySet: void <init>(java.util.Hashtable,java.util.Hashtable$1)>
  <java.util.Hashtable$Entry: void <init>(int,java.lang.Object,java.lang.Object,java.util.Hashtable$Entry)>
  <java.util.Hashtable$Enumerator: boolean hasMoreElements()>
  <java.util.Hashtable$Enumerator: boolean hasNext()>
  <java.util.Hashtable$Enumerator: java.lang.Object next()>
  <java.util.Hashtable$Enumerator: java.lang.Object nextElement()>
  <java.util.Hashtable$Enumerator: void <init>(java.util.Hashtable,int,boolean)>
  <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
  <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
  <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
  <java.util.Hashtable: java.util.Collection values()>
  <java.util.Hashtable: java.util.Hashtable$Entry[] access$400(java.util.Hashtable)>
  <java.util.Hashtable: java.util.Iterator access$100(java.util.Hashtable,int)>
  <java.util.Hashtable: java.util.Iterator getIterator(int)>
  <java.util.Hashtable: java.util.Set entrySet()>
  <java.util.Hashtable: void <init>()>
  <java.util.Hashtable: void <init>(int)>
  <java.util.Hashtable: void <init>(int,float)>
  <java.util.Hashtable: void rehash()>
  <java.util.jar.Attributes: java.lang.Object get(java.lang.Object)>
  <java.util.jar.Attributes: java.lang.Object put(java.lang.Object,java.lang.Object)>
  <java.util.jar.Attributes: java.lang.String getValue(java.lang.String)>
  <java.util.jar.Attributes: java.lang.String getValue(java.util.jar.Attributes$Name)>
  <java.util.jar.Attributes: java.lang.String putValue(java.lang.String,java.lang.String)>
  <java.util.jar.JarInputStream: void <init>(java.io.InputStream,boolean)>
  <java.util.jar.Manifest: void <init>()>
  <java.util.jar.Manifest: void <init>(java.io.InputStream)>
  <java.util.jar.Manifest: void read(java.io.InputStream)>
  <java.util.LinkedHashMap$EntryIterator: java.lang.Object next()>
  <java.util.LinkedHashMap$EntryIterator: java.util.Map$Entry next()>
  <java.util.LinkedHashMap$EntryIterator: void <init>(java.util.LinkedHashMap)>
  <java.util.LinkedHashMap$EntryIterator: void <init>(java.util.LinkedHashMap,java.util.LinkedHashMap$1)>
  <java.util.LinkedHashMap$Entry: void access$600(java.util.LinkedHashMap$Entry,java.util.LinkedHashMap$Entry)>
  <java.util.LinkedHashMap$Entry: void addBefore(java.util.LinkedHashMap$Entry)>
  <java.util.LinkedHashMap$Entry: void <init>(int,java.lang.Object,java.lang.Object,java.util.HashMap$Entry)>
  <java.util.LinkedHashMap$Entry: void recordAccess(java.util.HashMap)>
  <java.util.LinkedHashMap$Entry: void recordRemoval(java.util.HashMap)>
  <java.util.LinkedHashMap$Entry: void remove()>
  <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
  <java.util.LinkedHashMap: java.util.Iterator newEntryIterator()>
  <java.util.LinkedHashMap: java.util.Iterator newKeyIterator()>
  <java.util.LinkedHashMap: java.util.LinkedHashMap$Entry access$100(java.util.LinkedHashMap)>
  <java.util.LinkedHashMap$KeyIterator: java.lang.Object next()>
  <java.util.LinkedHashMap$KeyIterator: void <init>(java.util.LinkedHashMap)>
  <java.util.LinkedHashMap$KeyIterator: void <init>(java.util.LinkedHashMap,java.util.LinkedHashMap$1)>
  <java.util.LinkedHashMap$LinkedHashIterator: java.util.LinkedHashMap$Entry nextEntry()>
  <java.util.LinkedHashMap$LinkedHashIterator: void <init>(java.util.LinkedHashMap)>
  <java.util.LinkedHashMap$LinkedHashIterator: void <init>(java.util.LinkedHashMap,java.util.LinkedHashMap$1)>
  <java.util.LinkedHashMap$LinkedHashIterator: void remove()>
  <java.util.LinkedHashMap$ValueIterator: java.lang.Object next()>
  <java.util.LinkedHashMap: void addEntry(int,java.lang.Object,java.lang.Object,int)>
  <java.util.LinkedHashMap: void clear()>
  <java.util.LinkedHashMap: void createEntry(int,java.lang.Object,java.lang.Object,int)>
  <java.util.LinkedHashMap: void <init>()>
  <java.util.LinkedHashMap: void init()>
  <java.util.LinkedHashMap: void <init>(int,float)>
  <java.util.LinkedHashMap: void transfer(java.util.HashMap$Entry[])>
  <java.util.LinkedHashSet: void <init>()>
  <java.util.LinkedList: boolean addAll(int,java.util.Collection)>
  <java.util.LinkedList: boolean addAll(java.util.Collection)>
  <java.util.LinkedList: boolean add(java.lang.Object)>
  <java.util.LinkedList$Entry: void <init>(java.lang.Object,java.util.LinkedList$Entry,java.util.LinkedList$Entry)>
  <java.util.LinkedList: java.lang.Object[] toArray()>
  <java.util.LinkedList: java.util.LinkedList$Entry access$000(java.util.LinkedList)>
  <java.util.LinkedList: java.util.LinkedList$Entry addBefore(java.lang.Object,java.util.LinkedList$Entry)>
  <java.util.LinkedList: java.util.LinkedList$Entry entry(int)>
  <java.util.LinkedList: java.util.ListIterator listIterator(int)>
  <java.util.LinkedList$ListItr: java.lang.Object next()>
  <java.util.LinkedList$ListItr: void <init>(java.util.LinkedList,int)>
  <java.util.LinkedList: void <init>()>
  <java.util.LinkedList: void <init>(java.util.Collection)>
  <java.util.Properties: java.util.Enumeration propertyNames()>
  <java.util.Properties: void <init>()>
  <java.util.Properties: void <init>(java.util.Properties)>
  <java.util.PropertyResourceBundle: void <init>(java.io.InputStream)>
  <java.util.ResourceBundle$BundleReference: void <init>(java.util.ResourceBundle,java.lang.ref.ReferenceQueue,java.util.ResourceBundle$CacheKey)>
  <java.util.ResourceBundle$CacheKey: java.lang.Object clone()>
  <java.util.ResourceBundle: java.util.ResourceBundle findBundle(java.util.ResourceBundle$CacheKey,java.util.List,java.util.List,int,java.util.ResourceBundle$Control,java.util.ResourceBundle)>
  <java.util.ResourceBundle: java.util.ResourceBundle putBundleInCache(java.util.ResourceBundle$CacheKey,java.util.ResourceBundle,java.util.ResourceBundle$Control)>
  <java.util.ResourceBundle$LoaderReference: void <init>(java.lang.ClassLoader,java.lang.ref.ReferenceQueue,java.util.ResourceBundle$CacheKey)>
  <java.util.ServiceLoader$1: boolean hasNext()>
  <java.util.ServiceLoader$1: java.lang.Object next()>
  <java.util.ServiceLoader$1: void <init>(java.util.ServiceLoader)>
  <java.util.ServiceLoader: java.util.Iterator iterator()>
  <java.util.ServiceLoader$LazyIterator: boolean hasNext()>
  <java.util.ServiceLoader$LazyIterator: java.lang.Object next()>
  <java.util.Stack: java.lang.Object peek()>
  <java.util.Stack: java.lang.Object pop()>
  <java.util.Stack: java.lang.Object push(java.lang.Object)>
  <java.util.Stack: void <init>()>
  <java.util.TreeSet: java.lang.Object clone()>
  <java.util.Vector$1: java.lang.Object nextElement()>
  <java.util.Vector$1: void <init>(java.util.Vector)>
  <java.util.Vector: boolean add(java.lang.Object)>
  <java.util.Vector$Itr: java.lang.Object next()>
  <java.util.Vector: java.lang.Object clone()>
  <java.util.Vector: java.lang.Object elementAt(int)>
  <java.util.Vector: java.lang.Object elementData(int)>
  <java.util.Vector: java.lang.Object get(int)>
  <java.util.Vector: java.lang.Object remove(int)>
  <java.util.Vector: java.lang.Object set(int,java.lang.Object)>
  <java.util.Vector: java.lang.Object[] toArray()>
  <java.util.Vector: java.lang.Object[] toArray(java.lang.Object[])>
  <java.util.Vector: java.util.Enumeration elements()>
  <java.util.Vector: void addElement(java.lang.Object)>
  <java.util.Vector: void add(int,java.lang.Object)>
  <java.util.Vector: void ensureCapacityHelper(int)>
  <java.util.Vector: void <init>()>
  <java.util.Vector: void <init>(int)>
  <java.util.Vector: void <init>(int,int)>
  <java.util.Vector: void <init>(java.util.Collection)>
  <java.util.Vector: void insertElementAt(java.lang.Object,int)>
  <java.util.Vector: void removeElementAt(int)>
  <java.util.Vector: void setSize(int)>
  <java.util.WeakHashMap: boolean containsKey(java.lang.Object)>
  <java.util.WeakHashMap$Entry: void <init>(java.lang.Object,java.lang.Object,java.lang.ref.ReferenceQueue,int,java.util.WeakHashMap$Entry)>
  <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
  <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
  <java.util.WeakHashMap: java.util.WeakHashMap$Entry getEntry(java.lang.Object)>
  <java.util.WeakHashMap: void transfer(java.util.WeakHashMap$Entry[],java.util.WeakHashMap$Entry[])>
  <java.util.zip.InflaterInputStream: void <init>(java.io.InputStream,java.util.zip.Inflater,int)>
  <java.util.zip.ZipInputStream: java.util.zip.ZipEntry getNextEntry()>
  <java.util.zip.ZipInputStream: java.util.zip.ZipEntry readLOC()>
  <org.apache.lucene.index.SegmentInfos: void <init>()>
  <sun.misc.JarIndex: void add(java.lang.String,java.lang.String)>
  <sun.misc.JarIndex: void addToList(java.lang.String,java.lang.String,java.util.HashMap)>
  <sun.misc.Launcher$ExtClassLoader: void addExtURL(java.net.URL)>
  <sun.misc.SoftCache: java.lang.Object get(java.lang.Object)>
  <sun.misc.SoftCache$ValueCell: java.lang.Object access$300(java.lang.Object,boolean)>
  <sun.misc.SoftCache$ValueCell: java.lang.Object strip(java.lang.Object,boolean)>
  <sun.misc.SoftCache: void <init>(int)>
  <sun.misc.URLClassPath: void addURL(java.net.URL)>
  <sun.reflect.Reflection: java.util.Map registerFilter(java.util.Map,java.lang.Class,java.lang.String[])>
  <sun.security.pkcs.PKCS9Attribute: int indexOf(java.lang.Object,java.lang.Object[],int)>
  <sun.util.calendar.CalendarDate: java.lang.Object clone()>
  <sun.util.LocaleServiceProviderPool: java.lang.Object getLocalizedObjectImpl(sun.util.LocaleServiceProviderPool$LocalizedObjectGetter,java.util.Locale,boolean,java.lang.String,sun.util.resources.OpenListResourceBundle,java.lang.String,java.lang.Object[])>
  <sun.util.LocaleServiceProviderPool: java.lang.Object getLocalizedObject(sun.util.LocaleServiceProviderPool$LocalizedObjectGetter,java.util.Locale,sun.util.resources.OpenListResourceBundle,java.lang.String,java.lang.Object[])>
  <sun.util.TimeZoneNameUtility$TimeZoneNameGetter: java.lang.Object getObject(java.lang.Object,java.util.Locale,java.lang.String,java.lang.Object[])>
  <sun.util.TimeZoneNameUtility$TimeZoneNameGetter: java.lang.String[] examineAliases(java.util.spi.TimeZoneNameProvider,java.util.Locale,java.lang.String,java.util.Map,java.util.Set)>
  <sun.util.TimeZoneNameUtility$TimeZoneNameGetter: java.lang.String[] getObject(java.util.spi.TimeZoneNameProvider,java.util.Locale,java.lang.String,java.lang.Object[])>
